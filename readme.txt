Choice of Algorithm:The sudoku was approached as a graph search problem. The graph is represented implicitly by the initial state (given sudoku boards), the actions possible (rules), and states (built from actions taken).Each possible action can be represented as the nodes of a tree structure, the potential search tree.The search implements a constraint satisfaction backtracking algorithm that moves across the tree recursively, from the root down in depth-first order.A number is placed in the first available space, this is checked to be valid against the row, column, and square. If it is valid, the domain is updated as the numpy grid is mutable. When the next number is placed, this will be checked against the updated numpy grid. This determines our constraint propagation.If we become stuck, we backtrack and try the next number.Code Methods:The method taken is to first find an empty square in the sudoku, represented by a 0. We can create a method that checks every spot in the grid and returns the first empty spot found.Similar to how we could play regularly, we can check if a number is a valid move in the empty spot. A method is created that takes the empty spot, and then checks if the number is valid by seeing if the number is already in the row, or column, or square.If it’s valid we can fill the spot, if not we try the next number. Our guesses are made by just starting at 1 and trying each number through to 9.This process implements the backtracking search, combining depth-first and constraint propagation.An extra method is created to check if the board is in a valid starting state. It ensures the starting grid has no columns or rows with the same number.Complexity:The space complexity O(bd) can be calculated with branching factor b = 9 (9 possibilities per square) and a depth of possible spaces as d = 81 (9x9 grid). 1.9662705e+77 possible nodes to explore. Testing on a blank board however gave us a quick output due to the solution being possible by iterating upwards from left to right as per our algorithm. On extremely difficult grids the code can timeout due to this large complexity.An improvement:The search_empty method could be improved by implementing an informed search. A heuristic function could be used to determine the next best state. This could be evaluated by finding the row with the least amount of 0s and starting at those points. Each row can be added to the frontier with the lowest value being the least amount of 0s. This greedy first-search method would be advantageous in sudoku as there would then be fewer possible values to fill there.